I"+<ul id="markdown-toc" role="doc-toc">
  <li><a href="#http协议的作用及特点" id="markdown-toc-http协议的作用及特点">http协议的作用及特点</a></li>
  <li><a href="#协议的组成" id="markdown-toc-协议的组成">协议的组成</a></li>
  <li><a href="#请求方法" id="markdown-toc-请求方法">请求方法</a></li>
  <li><a href="#状态码" id="markdown-toc-状态码">状态码</a></li>
  <li><a href="#content-type请求报文头属性" id="markdown-toc-content-type请求报文头属性">Content-Type(请求报文头属性)</a></li>
  <li><a href="#tcp三次握手" id="markdown-toc-tcp三次握手">TCP三次握手</a></li>
  <li><a href="#四次挥手" id="markdown-toc-四次挥手">四次挥手</a></li>
</ul>

<blockquote>
  <p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法</p>
</blockquote>

<h4 id="http协议的作用及特点">http协议的作用及特点</h4>
<p>HTTP是一个客户端和服务器端请求和应答的标准,客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫<code class="highlighter-rouge">用户代理</code>。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）</p>

<p>1.基于请求/响应模型的协议。请求和响应必须成对，先有请求后有响应。</p>

<p>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST、DELETE、PUT、TRACE、PATCH、CONNECT、OPTIONS。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>

<p>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>

<p>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>

<p>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>

<h4 id="协议的组成">协议的组成</h4>
<p>http请求包括:请求行、请求头、请求体
http响应包括:响应行、响应头、响应体</p>

<h4 id="请求方法">请求方法</h4>
<p><code class="highlighter-rouge">get请求</code>
将请求参数追加在url后面，不安全
url长度限制get请求方式数据的大小
没有请求体</p>

<p><code class="highlighter-rouge">post请求</code>
请求参数在请求体处，较安全。
请求数据大小没有限制</p>

<p><code class="highlighter-rouge">HEAD请求</code>
HEAD跟GET相似，不过服务端接收到HEAD请求时只返回响应头，不发送响应内容。所以，如果只需要查看某个页面的状态时，用HEAD更高效，因为省去了传输页面内容的时间。</p>

<p><code class="highlighter-rouge">DELETE请求</code>
删除某一个资源。</p>

<p><code class="highlighter-rouge">OPTIONS请求</code>
用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p>

<p><code class="highlighter-rouge">PUT请求</code>
把一个资源存放在指定的位置上。</p>

<p>本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p>

<p><code class="highlighter-rouge">TRACE请求</code>
回显服务器收到的请求，主要用于测试或诊断。</p>

<p><code class="highlighter-rouge">CONNECT请求</code>
CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p>

<h4 id="状态码">状态码</h4>
<ul>
  <li>1xx：指示信息，表示请求已接收，继续处理</li>
  <li>
    <p>2xx：成功，表示请求已被成功接受，处理。</p>
  </li>
  <li>200 OK：客户端请求成功</li>
  <li>204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。</li>
  <li>
    <p>206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容</p>
  </li>
  <li>3xx：重定向</li>
  <li>301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。</li>
  <li>302 Found：临时重定向，表示请求的资源临时搬到了其他位置</li>
  <li>303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问</li>
  <li>307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET</li>
  <li>
    <p>304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有</p>
  </li>
  <li>4xx：客户端错误</li>
  <li>400 Bad Request：客户端请求有语法错误，服务器无法理解。</li>
  <li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>
  <li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li>
  <li>404 Not Found：请求资源不存在。比如，输入了错误的url</li>
  <li>
    <p>415 Unsupported media type：不支持的媒体类型</p>
  </li>
  <li>5xx：服务器端错误，服务器未能实现合法的请求。</li>
  <li>500 Internal Server Error：服务器发生不可预期的错误。</li>
  <li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>

<h4 id="content-type请求报文头属性">Content-Type(请求报文头属性)</h4>

<table>
  <thead>
    <tr>
      <th>Content-Type</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>text/html</td>
      <td>html格式</td>
    </tr>
    <tr>
      <td>text/plain</td>
      <td>纯文本格式</td>
    </tr>
    <tr>
      <td>text/css</td>
      <td>css格式</td>
    </tr>
    <tr>
      <td>text/javascript</td>
      <td>js格式</td>
    </tr>
    <tr>
      <td>image/gif</td>
      <td>gif图片格式</td>
    </tr>
    <tr>
      <td>image/*</td>
      <td>其他图片格式</td>
    </tr>
    <tr>
      <td>application/x-www-form-urlencoded</td>
      <td>POST专用：普通的表单提交默认是通过这种方式。form表单数据被编码为key/value格式发送到服务器。</td>
    </tr>
    <tr>
      <td>application/json</td>
      <td>POST专用：用来告诉服务端消息主体是序列化后的 JSON 字符串</td>
    </tr>
    <tr>
      <td>text/xml</td>
      <td>POST专用：发送xml数据</td>
    </tr>
    <tr>
      <td>multipart/form-data</td>
      <td>POST专用：使用表单上传文件</td>
    </tr>
  </tbody>
</table>

<h4 id="tcp三次握手">TCP三次握手</h4>
<blockquote>
  <p><code class="highlighter-rouge">进行三次握手的原因</code>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
</blockquote>

<p><code class="highlighter-rouge">图解</code></p>

<p><img src="/styles/images/three.png" alt="/styles/images/three.png" /></p>

<ul>
  <li>
    <p>第一次握手
        建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
  </li>
  <li>
    <p>第二次握手
        服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
  </li>
  <li>
    <p>第三次握手
       客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
  </li>
</ul>

<p>===========================</p>

<h4 id="四次挥手">四次挥手</h4>
<blockquote>
  <p><code class="highlighter-rouge">进行四次挥手的原因</code>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
</blockquote>

<p><code class="highlighter-rouge">图解</code></p>

<p><img src="/styles/images/four.png" alt="/styles/images/four.png" /></p>

<ul>
  <li>
    <p>第一次分手
       主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p>
  </li>
  <li>
    <p>第二次分手
       主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p>
  </li>
  <li>
    <p>第三次分手
       主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p>
  </li>
  <li>
    <p>第四次分手
       主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
  </li>
</ul>

:ET